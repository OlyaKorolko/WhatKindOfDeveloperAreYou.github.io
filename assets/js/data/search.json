[ { "title": "Arrow to the Knee: Editing unordered_multiset items", "url": "/posts/ArrowToTheKneeEditingUnorderedMultisetItems/", "categories": "Notes, Arrow to the Knee", "tags": "Arrow to the Knee, C++, Containers", "date": "2022-06-20 12:20:00 +0300", "snippet": "Have you ever thought of editing std::unordered_multiset items while iterating over it? Does it even make sense?In this post I will tell you why and how I tried to do it and what happened to my code afterwards.Getting into positionstd::unordered_multiset iterator returns const references to items and it works like that for a reason: developersnever expected that some phycho would try to edit items during iteration. And even if they did expect it,the is no practical way to make this work, because there is no cheap way to teach std::unordered_multisetto track changes in its records.So, why did I need to edit items, after all? This case arised during Pegasusdevelopment: user requests write access to record and we need to provide this access as fast as possible and only afteruser has done everything needed to be done we are checking whether key fields are different. Of course, to do this checkwe also have separate preallocated record that stores only key fields. So, when we know that user has changed key fields, we need to somehow update std::unordered_multiset according to these changes.There is one more case which is even more complicated from the first glance: user might just delete record and in thiscase we don’t want to check whether key fields were changed, we want to just erase this record right away.Getting shotThe first thought that came to my mind was: Oh, we already have iterators, so we can just erase and then emplace and everything will be fine!Sounds reasonable, right? Even if value is not the same as it was before, we still have valid iterator,so any operations with it should work fine. But it isn’t the case with unordered containers.The thing is, just having the iterator is not enough to perform the erasure properly: during erasure unorderedcontainer needs to calculate hash once more and that is where things are getting fucked up, because hash is different now.To check, try running this snippet using any compiler and any STD implementation you like:std::unordered_multiset &lt;int&gt; set;set.emplace (1);set.emplace (2);set.emplace (3); auto iterator = set.find (2);const_cast &lt;int&amp;&gt; (*iterator) = 4;set.erase (iterator); for (const int &amp;number : set){ std::cout &lt;&lt; number &lt;&lt; std::endl;}You can also try to execute it with numbers other than 4: it would result in unexpected (or, sometimes, normal, but not really expacted) behaviours.Healing the woundsBut in Pegasuseverything works fine, so there is solution for this problem, right? Yep, there is! A bit clunky and ad hok though.We can start from the fact that we need to somehow keep hash the same after changing key fields. That means, thatwe need to roll key fields back to their initial values, right? This is one way to think about that. And it is closeto howPegasusactually deals with this problem: it stores multiset of pointers and it already has preallocated record with initialvalues for change checking, therefore we can just edit iterator like that:// Copy link to the record for further usage.const void *record = *_position;// Replace iterator content with backup to make hash result valid.const_cast&lt;void const *&amp;&gt; (*_position) = storage-&gt;GetEditedRecordBackup ();// Now we can safely erase record from our set.records.erase (_position);// And reinsert our changed record!records.emplace_back (record);Code above is a simplified version of whatPegasusdoes.But what if you don’t have record backup? Well, if you know index count during compile time, which is not the case forPegasus, there is another way do deal with this problem: storing hash as additional field and recalculating it only afterrecord is erased from the map. Unfortunately, I’ve never tried it myself, so I can not tell you more about this method.Hope you’ve enjoyed reading about this tragic failings with std::unordered_set! :)" }, { "title": "Hint: Global Initialization Order", "url": "/posts/HintGlobalInitializationOrder/", "categories": "Notes, Hints", "tags": "Notes, C++", "date": "2022-06-18 19:30:00 +0300", "snippet": "Global initialization order is rather trivial thing, but anyone encounters mistakes related to it one day or another.I’ve decided to post this hint, that I would’ve given to my past self. Lets start from the problem definition.ProblemLets imagine that we have these two static fields:class MyHolderClass final{ static AClass aObject; static BClass bObject;};It doesn’t change things whether they are inside one holder class, two different ones or are top level citizens.There is one possible problem: aObject initializer might access bObject, but bObject is not yet initialized, or vice versa. Therefore, access to uninitialized memory occurs and what happens then no one can predict:behaviour varies from blunt crashes to subtle bugs.I guess, everyone sooner or later encounters bugs related to this problem. And everyone who encountered them knowsthat it is pain in the ass to debug them. So, how to avoid this problem?SolutionThankfully, there is such thing as function-scope static variables, that are initialized during first call to the function. Of course, they have small impact on performance (close to one additional if per call, I guess),but they allow us to forget about initialization order problems once and for all.// Header file.class MyHolderClass final{ static AClass &amp;GetA (); static BClass &amp;GetB ();};// Object file.AClass &amp;MyHolderClass::GetA (){ static AClass aObject; return aObject;}BClass &amp;MyHolderClass::GetB (){ static BClass bObject; return bObject;}In this case, function call always guarantees that aObject and bObject are initialized by the time they areaccessed. And if their initializators depend one on another, we will receive easily debuggable stackoverflow crash.When this solution is bad If you’re perfectly sure that static global variables are never accessed during global initialization, it’s betterto avoid packing them inside functions, because by packing you might reduce readability and introduce additionalperformance cost to variable access. If your hot path code accesses this global variable and needs to achieve top notch performance, it is unwiseto add one unnecessary if to the equation (and possibly add one function call too, if LTOs are not smart enough). So, choose wisely! :)This post might sound really trivial, but you shouldn’t just ignore this theme. I’ve encountered mistakes like this in some codebases (hello Vizor Games mobile department!) and it wasn’t very pleasant." }, { "title": "Emergence: What & Why?", "url": "/posts/EmergenceWhat&Why/", "categories": "Emergence, Development Log", "tags": "Emergence, C++, GameDev", "date": "2022-06-18 17:00:00 +0300", "snippet": "I’ve been developing Emergence project for more than a year. Or two years, if you count previous unfortunate attempt!I’ve decided to finally come out of the shadow and start writing about it. Today I will talk about how I decided to start this project.This is my first post on this blog, therefore I think it’s good idea to share what kinds of posts I plan to do later: Emergence Development Log: Everything about Emergence projectdevelopment. Emergence tutorials: Tutorials about how to work with Emergencelibraries once they’re ready, of course. :) Hints: Small notes about different aspects of programming. Arrow to the Knee: name speaks for itself, I guess. These notes will be about shooting yourself with your code. There might be articles and tutorials about general topics, connected to game development, but I’m not sure yet.If you’d like to get notifications about new posts, subscribe to my Telegram channel. :)MotivationI’ve discovered data-driven programming when I joined BattlePrime team. These guys were really cool professionals and I’m glad that I was working with them.After years of object oriented development I was really excited to try something new and quickly became true ECS zealot.But there were a lot of flaws in our ECS design too, not because people were unprofessional, but because designing architecture is generally difficult.From my perspective, so called flag-components were one of the main problems with our design. We had AliveComponent, DeadComponent, ActiveAvatarComponent, ControlledByPlayerComponent and so on. These components had no data and were only used to filter entities through components masks.I was thinking about this a lot and one question was arising on and on: why can’t we just use query-like API instead ofclassic ECS entity families?I was digging further and further into this why not queries? question and started believing in database-drivenECS concept.Yes, it’s not new and many people before me tried to implement it and failed.But this idea was still very interesting and motivating for me.I had a lot of questions. What is the difference between receiving component from entity and quering by entity id?Why do we even need entities, when everything could be records, loosely connected by indexed queries?So, I decided to write my own ECS framework with database-like style and prostitutes queries.Also, I was dissatisfied with some concepts, that were highly used in BattlePrime andsome other ECS frameworks. Therefore I decided to stick to some additional rules while writing Emergence: There should be no virtual methods, unless they are required by third party libraries. virtuals are not onlykind of slow from performance point of view, but also a source of unknown behaviour. By allowing to put almosteverything into everything, virtuals might lead to strange bugs and unnecessary complications. I decided that Iwant everything to be straighforward, therefore there should be no virtuals. Template usage should be minimized. There are some people out there that really really love templates, but usuallythey ignore one significant drawback: compile time. One engineer in BattlePrime teamcalculated that including &lt;core/entity.h&gt; increases unit compile time by roughly 6 seconds. And &lt;core/entity.h&gt;was, obviously, included everywhere. In my opinion, long compile times make programming unbearable, therefore Idecided to limit template usage in order to have reasonable compile time. Multithreaded code must be planned to be multithreaded from the beggining, not ad-hooked to be multithreaded after.One of the main advantages of data-driven design is that it is usually much easier to adapt it for parallel executionin comparison to classic OOP approach. Unfortunately, BattlePrime team was never ableto make their ECS truly parallel: they tried several times, but failed. One of the biggest problems was that their ECS was never designed to be multithreaded in the first place, therefore I decided to think about multithreadingfrom the start. There was also one additional thing I wanted to try out during Emergence development: link time polymorphism. It sounded likesomething unbelievable: polymorphism without runtime performance and compile time drawbacks.GoalsAfter failing my previous attempt – Temple – I’ve decided that I need to understand better what am I writing before starting again from scratch.I planned to create several disconnected or loosly connected modules and built my own ECS on top of them.And that’s exactly why I called this project Emergence: my ECS framework would emerge on top of different disconnectedlibraries, like consciousness on top of our neurons in emergent consciousness philosophy. Below I will provide the listof the libraries I planned: CMake framework for link time polymorphism. I’ve planned many libraries and I needed good support from the buildsystem for my beloved link time polymorphism. :) Memory allocation library with pools, stacks, unique strings and hierarchical memory profiling. While first onesare quite easy to implement, hierarchical (aka “build memory usage flame graph for me, bitch”) memory profilingwas quite tricky, because I wasn’t able to find any opensource tools that can do that. Simplistic field-only reflection, that also knows about constructors and destructors. I needed reflection forcomponent indexing and I didn’t want to use any of the existing heavyweight libraries, therefore I decided to createmy own lightweight library. Logging library, possibly a wrapper for some logging framework. How can you track bugs without logging? Utility for rendering complex runtime structures into DOT graphs. It is always useful to render your system graph orsome other data. Indexed object storage. Just a simple collection of objects with one no-so-simple feature: it must provide userwith an opportunity to create hash indices, sorted indices and volumetric (aka bounding box) indices. Library for managing indexed object storages, that also supports unindexed storages and singletons. Sounds exactly like ECS World, isn’t it? Library for registering and executing parallel tasks, that use shared resources and depend on each other. Also,this library needs to detect circular dependencies and race conditions. It would later be executing systems insidemy ECS framework. And finnaly, pinnacle of the human development, my ECS framework. :D What is it now?Almost a year and three month have passed since I started developing Emergence, and I’m glad to say that almost all goals aboveare fullfilled. Just one thing left to be done: I need to develop small proof-of-concept project to checkwhether my ECS framework is good at doing what it needs to do. But, as it always happens, this last thing ismuch more complex than it sounds: to finish this project, I need to at least integrate physics and graphics. AndI’ve already finished small PhysX and Urho3D integrations, but who knows what other integrations I might need later.I hope to finish proof-of-concept during next month or two and finally be able to present my beloved ECS frameworkto the public. Lets just hope that there won’t be any complex obstacles to doing so.That’s all for now. Hope you’ve enjoyed reading this article. :)" } ]
